---
title: "Bacteria Unsupervised Clustering"
author: "Cassandra Sperow"
date: "2023-09-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(stats)
setwd("/Users/kasan/AU My Drive/001__DATA_793/R_dir_Corals_")
suppressMessages(library(tidyverse))

```

# Unsupervised Clustering of Bacteria 

Goal:  Find groups (i.e., essentially networks) of bacteria that tend to be found together. Use these to see if bacteria features can be paired down from the already reduced 5,890 ASV ```rev_bacteria_prop_df``` . 

- Use the results from the PCA that about 239 principal components explain at least 80 % of the bacteria data.


### Read in ```rev_bacteria_prop_df``` data
- This is the revised bacteria data that is proportion-based by row sums. See `Bacteria_Proportions.Rmd` for details. 
```{r}
# read in the new proportion-based bacteria data
read_csv("../output/rev_bacteria_prop_df.csv") -> rev_bacteria_prop_df

head(rev_bacteria_prop_df)
```

## Test stability of K-means on subset of data, default K-means algorithm
```{r}
set.seed(92)
random_columns = sample(1:5890, size=2000)

rev_bacteria_prop_df %>% 
  # random sample of rows
  slice_sample(n=400) %>% 
  # random sample of columns indexed with random generator above
  select(all_of(random_columns)) -> random_subset

random_subset %>% head()

dim(random_subset) # 400 by 2000

```

- Random subset keeps giving me columns that have NaN values when scaled in K-means, so need to take out those columns for a good subset while still having a lot more columns than observations like original.
```{r}
random_subset %>% 
  scale() %>% as.data.frame() %>% 
  map(., ~sum(is.nan(.))) %>% as.data.frame() %>% 
  t() %>%  as.data.frame() %>% 
  filter(V1 == 0) 

scale(random_subset) %>% as.data.frame()
```


- Question for Dr. Barouti:  If K-means is giving random results every time I run it, is it a good method to use since this seems unstable? (The sizes of the 239 clusters change each time.)
```{r}
# stats::kmeans(scale(random_subset), 
#               centers = 239, 
#               #nstart = 10 # takes long time to run
#               ) -> kmeans_out
```

```{r}
# create object to pass into solution for removing columns that have any sort of NaN value
scale(random_subset) -> sc_random

# solution used via this link
# https://stackoverflow.com/questions/12454487/remove-columns-from-dataframe-where-some-of-values-are-na
sc_random[, colSums(is.nan(sc_random)) == 0] %>% 
  as.data.frame() -> sc_random_df
```


```{r}
stats::kmeans(sc_random_df, 
              centers = 239, 
              #nstart = 10 # takes long time to run
              ) -> kmeans_out
```

```{r}
summary(kmeans_out)
```


```{r}
kmeans_out$size
```

- Re-running K-means on the subset of random rows and columns returns consistently unstable sizes of clusters. Setting the seed would be an artificial fix and wouldn't be a true representation of the bacterial groups. 

- Can I find a better k?

https://rpkgs.datanovia.com/factoextra/

https://www.datanovia.com/en/lessons/determining-the-optimal-number-of-clusters-3-must-know-methods/

- Trying ```factoextra``` package to find best ```k```:
- **This took too long (over 20 mins) to run**
- Did not converge
```{r}
# library("factoextra")
# fviz_nbclust(sc_random_df,
#              kmeans,
#              k.max = 250,
#              method = "gap_stat")
```

# K-Means with Transposed Rows and Columns: Default K-means Algorithm
- Because K-Means clusters by row, so put the rows as the bacteria. 
- If K-Means works by row, and if the point is to cluster the bacteria, then why don't I try to transpose to where the bacteria are rows?
```{r}
rev_bacteria_prop_df %>% 
  t() %>% 
  as.data.frame() %>% 
  janitor::row_to_names(1) %>% 
  map(., ~as.numeric(.)) %>% 
  as.data.frame() -> rev_bacteria_prop_t
```



```{r}
stats::kmeans(scale(rev_bacteria_prop_t), 
              centers = 239, 
              iter.max = 50 # twice it has not converged in default 10 iter
              ) -> t_kmeans_out
```

Notes from Ressler: 

- Increasing k will always increase R2, but do not want to introduce bias just for only a little gain. This is where the plot begins to plateau such that there is little gain in R2 as k increases. This means there is potential bias and we would like a k value at the 'knee' in the plot which is around k=4. 

- The 'knee' point means that k=4 is a possible optimized number of clusters according to the R2, but the leveling off as k reaches 7-10 indicates that the gains with one more cluster are possibly not worth it, but we can also estimate k other ways.

### Does Using Transposed Data Create More Stable Output?
- No, the sizes and clusters are still different every time. 
```{r}

t_kmeans_out$size
```
### Try different K-means Algorithm of MacQueen
```{r}
# algorithm of Hartigan and Wong (1979) used by default
# change to experiment with MacQueen 
stats::kmeans(scale(rev_bacteria_prop_t), 
              centers = 239, 
              algorithm = "MacQueen",
              iter.max = 50 # twice it has not converged in default 10 iter
              ) -> t_kmeans_out_Q
```

- One thing that's stable is that it's always giving a cluster with at least 4,000 in one of the sizes each time I re-rum (re-ran randomly 5x): 
```{r}
t_kmeans_out_Q$size
```

```{r}

which.max(t_kmeans_out_Q$size)
```

```{r}
plot(t_kmeans_out_Q$cluster)
plot(t_kmeans_out_Q$size) # one group of over 4K
```

```{r}
plot(1:length(t_kmeans_out_Q$size), t_kmeans_out_Q$withinss)
```

- X-axis as the number of clusters of 239 based on PCA
- Y-axis as the within cluster sums of squares for each cluster
- Goal is to minimize the within cluster sum of squares but some are very high

```{r}
library(factoextra)
fviz_cluster(t_kmeans_out_Q, 
             data = rev_bacteria_prop_t, 
             legend = "none"
             )
```


### NbClust Library with Factoextra Viz
```{r}
library(NbClust)
NbClust(distance = "euclidean",
        data = scale(rev_bacteria_prop_t),
        method = "complete",
        min.nc = 20,
        max.nc = 250,
        index = "all") -> nb1



```

```{r}

```

```{r}

```





```{r}
```


```{r}
```


```{r}
```


```{r}
```


```{r}
```


```{r}
```




